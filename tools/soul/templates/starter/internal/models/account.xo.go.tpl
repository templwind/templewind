// Package models contains generated code for schema 'data.db'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Account represents a row from 'accounts'.
type Account struct {
	ID            string         `json:"id" db:"id" form:"id"`                                        // id
	CompanyName   sql.NullString `json:"company_name" db:"company_name" form:"company_name"`          // company_name
	Address1      sql.NullString `json:"address_1" db:"address_1" form:"address_1"`                   // address_1
	Address2      sql.NullString `json:"address_2" db:"address_2" form:"address_2"`                   // address_2
	City          sql.NullString `json:"city" db:"city" form:"city"`                                  // city
	StateProvince sql.NullString `json:"state_province" db:"state_province" form:"state_province"`    // state_province
	PostalCode    sql.NullString `json:"postal_code" db:"postal_code" form:"postal_code"`             // postal_code
	Country       sql.NullString `json:"country" db:"country" form:"country"`                         // country
	Phone         sql.NullString `json:"phone" db:"phone" form:"phone"`                               // phone
	Email         sql.NullString `json:"email" db:"email" form:"email"`                               // email
	Website       sql.NullString `json:"website" db:"website" form:"website"`                         // website
	PrimaryUserID string         `json:"primary_user_id" db:"primary_user_id" form:"primary_user_id"` // primary_user_id
	CreatedAt     string         `json:"created_at" db:"created_at" form:"created_at"`                // created_at
	UpdatedAt     string         `json:"updated_at" db:"updated_at" form:"updated_at"`                // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Account] exists in the database.
func (a *Account) Exists() bool {
	return a._exists
}

// Deleted returns true when the [Account] has been marked for deletion
// from the database.
func (a *Account) Deleted() bool {
	return a._deleted
}

// Insert inserts the [Account] to the database.
func (a *Account) Insert(ctx context.Context, db DB) error {
	switch {
	case a._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case a._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO accounts (` +
		`id, company_name, address_1, address_2, city, state_province, postal_code, country, phone, email, website, primary_user_id, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`)`
	// run
	logf(sqlstr, a.ID, a.CompanyName, a.Address1, a.Address2, a.City, a.StateProvince, a.PostalCode, a.Country, a.Phone, a.Email, a.Website, a.PrimaryUserID, a.CreatedAt, a.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, a.ID, a.CompanyName, a.Address1, a.Address2, a.City, a.StateProvince, a.PostalCode, a.Country, a.Phone, a.Email, a.Website, a.PrimaryUserID, a.CreatedAt, a.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	a._exists = true
	return nil
}

// Update updates a [Account] in the database.
func (a *Account) Update(ctx context.Context, db DB) error {
	switch {
	case !a._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case a._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE accounts SET ` +
		`company_name = $1, address_1 = $2, address_2 = $3, city = $4, state_province = $5, postal_code = $6, country = $7, phone = $8, email = $9, website = $10, primary_user_id = $11, created_at = $12, updated_at = $13 ` +
		`WHERE id = $14`
	// run
	logf(sqlstr, a.CompanyName, a.Address1, a.Address2, a.City, a.StateProvince, a.PostalCode, a.Country, a.Phone, a.Email, a.Website, a.PrimaryUserID, a.CreatedAt, a.UpdatedAt, a.ID)
	if _, err := db.ExecContext(ctx, sqlstr, a.CompanyName, a.Address1, a.Address2, a.City, a.StateProvince, a.PostalCode, a.Country, a.Phone, a.Email, a.Website, a.PrimaryUserID, a.CreatedAt, a.UpdatedAt, a.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Account] to the database.
func (a *Account) Save(ctx context.Context, db DB) error {
	if a.Exists() {
		return a.Update(ctx, db)
	}
	return a.Insert(ctx, db)
}

// Upsert performs an upsert for [Account].
func (a *Account) Upsert(ctx context.Context, db DB) error {
	switch {
	case a._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO accounts (` +
		`id, company_name, address_1, address_2, city, state_province, postal_code, country, phone, email, website, primary_user_id, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`company_name = EXCLUDED.company_name, address_1 = EXCLUDED.address_1, address_2 = EXCLUDED.address_2, city = EXCLUDED.city, state_province = EXCLUDED.state_province, postal_code = EXCLUDED.postal_code, country = EXCLUDED.country, phone = EXCLUDED.phone, email = EXCLUDED.email, website = EXCLUDED.website, primary_user_id = EXCLUDED.primary_user_id, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, a.ID, a.CompanyName, a.Address1, a.Address2, a.City, a.StateProvince, a.PostalCode, a.Country, a.Phone, a.Email, a.Website, a.PrimaryUserID, a.CreatedAt, a.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, a.ID, a.CompanyName, a.Address1, a.Address2, a.City, a.StateProvince, a.PostalCode, a.Country, a.Phone, a.Email, a.Website, a.PrimaryUserID, a.CreatedAt, a.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	a._exists = true
	return nil
}

// Delete deletes the [Account] from the database.
func (a *Account) Delete(ctx context.Context, db DB) error {
	switch {
	case !a._exists: // doesn't exist
		return nil
	case a._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM accounts ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, a.ID)
	if _, err := db.ExecContext(ctx, sqlstr, a.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	a._deleted = true
	return nil
}

// AccountByID retrieves a row from 'accounts' as a [Account].
//
// Generated from index 'sqlite_autoindex_accounts_1'.
func AccountByID(ctx context.Context, db DB, id string) (*Account, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, company_name, address_1, address_2, city, state_province, postal_code, country, phone, email, website, primary_user_id, created_at, updated_at ` +
		`FROM accounts ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	a := Account{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&a.ID, &a.CompanyName, &a.Address1, &a.Address2, &a.City, &a.StateProvince, &a.PostalCode, &a.Country, &a.Phone, &a.Email, &a.Website, &a.PrimaryUserID, &a.CreatedAt, &a.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &a, nil
}
